# NOTE: This class is auto generated by the swagger code generator program.
# https://github.com/swagger-api/swagger-codegen.git
# Do not edit the class manually.

defmodule Asterisk.ARI.Api.ApiDocsbridgesFormat do
  @moduledoc """
  API calls for all endpoints tagged `ApiDocsbridgesFormat`.
  """

  alias Asterisk.ARI.Connection
  import Asterisk.ARI.RequestBuilder


  @doc """
  Add a channel to a bridge.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - channel ([String.t]): Ids of channels to add to bridge
  - opts (KeywordList): [optional] Optional parameters
    - :role (String.t): Channel&#39;s role in the bridge
    - :absorb_dtmf (boolean()): Absorb DTMF coming from this channel, preventing it to pass through to the bridge
    - :mute (boolean()): Mute audio from this channel, preventing it to pass through to the bridge

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec add_channel(Tesla.Env.client, String.t, list(String.t), keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def add_channel(connection, bridge_id, channel, opts \\ []) do
    optional_params = %{
      :"role" => :query,
      :"absorbDTMF" => :query,
      :"mute" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/addChannel")
    |> add_param(:query, :"channel", channel)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec clear_video_source(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def clear_video_source(connection, bridge_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/bridges/#{bridge_id}/videoSource")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Create a new bridge.
  This bridge persists until it has been shut down, or Asterisk has been shut down.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :type (String.t): Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu).
    - :bridge_id (String.t): Unique ID to give to the bridge being created.
    - :name (String.t): Name to give to the bridge being created.

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec create(Tesla.Env.client, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def create(connection, opts \\ []) do
    optional_params = %{
      :"type" => :query,
      :"bridgeId" => :query,
      :"name" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Create a new bridge or updates an existing one.
  This bridge persists until it has been shut down, or Asterisk has been shut down.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Unique ID to give to the bridge being created.
  - opts (KeywordList): [optional] Optional parameters
    - :type (String.t): Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu) to set.
    - :name (String.t): Set the name of the bridge.

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec create_with_id(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def create_with_id(connection, bridge_id, opts \\ []) do
    optional_params = %{
      :"type" => :query,
      :"name" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Shut down a bridge.
  If any channels are in this bridge, they will be removed and resume whatever they were doing beforehand.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec destroy(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def destroy(connection, bridge_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/bridges/#{bridge_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Get bridge details.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec get(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def get(connection, bridge_id, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/bridges/#{bridge_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  List all active bridges in Asterisk.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec list(Tesla.Env.client, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def list(connection, _opts \\ []) do
    %{}
    |> method(:get)
    |> url("/bridges")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Start playback of media on a bridge.
  The media URI may be any of a number of URI&#39;s. Currently sound:, recording:, number:, digits:, characters:, and tone: URI&#39;s are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - media ([String.t]): Media URIs to play.
  - opts (KeywordList): [optional] Optional parameters
    - :lang (String.t): For sounds, selects language for sound.
    - :offsetms (integer()): Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
    - :skipms (integer()): Number of milliseconds to skip for forward/reverse operations.
    - :playback_id (String.t): Playback Id.

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec play(Tesla.Env.client, String.t, list(String.t), keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def play(connection, bridge_id, media, opts \\ []) do
    optional_params = %{
      :"lang" => :query,
      :"offsetms" => :query,
      :"skipms" => :query,
      :"playbackId" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/play")
    |> add_param(:query, :"media", media)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Start playback of media on a bridge.
  The media URI may be any of a number of URI&#39;s. Currently sound:, recording:, number:, digits:, characters:, and tone: URI&#39;s are supported. This operation creates a playback resource that can be used to control the playback of media (pause, rewind, fast forward, etc.)

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - playback_id (String.t): Playback ID.
  - media ([String.t]): Media URIs to play.
  - opts (KeywordList): [optional] Optional parameters
    - :lang (String.t): For sounds, selects language for sound.
    - :offsetms (integer()): Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
    - :skipms (integer()): Number of milliseconds to skip for forward/reverse operations.

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec play_with_id(Tesla.Env.client, String.t, String.t, list(String.t), keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def play_with_id(connection, bridge_id, playback_id, media, opts \\ []) do
    optional_params = %{
      :"lang" => :query,
      :"offsetms" => :query,
      :"skipms" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/play/#{playback_id}")
    |> add_param(:query, :"media", media)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Start a recording.
  This records the mixed audio from all channels participating in this bridge.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - name (String.t): Recording&#39;s filename
  - format (String.t): Format to encode audio in
  - opts (KeywordList): [optional] Optional parameters
    - :max_duration_seconds (integer()): Maximum duration of the recording, in seconds. 0 for no limit.
    - :max_silence_seconds (integer()): Maximum duration of silence, in seconds. 0 for no limit.
    - :if_exists (String.t): Action to take if a recording with the same name already exists.
    - :beep (boolean()): Play beep when recording begins
    - :terminate_on (String.t): DTMF input to terminate recording.

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec record(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def record(connection, bridge_id, name, format, opts \\ []) do
    optional_params = %{
      :"maxDurationSeconds" => :query,
      :"maxSilenceSeconds" => :query,
      :"ifExists" => :query,
      :"beep" => :query,
      :"terminateOn" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/record")
    |> add_param(:query, :"name", name)
    |> add_param(:query, :"format", format)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Remove a channel from a bridge.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - channel ([String.t]): Ids of channels to remove from bridge
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec remove_channel(Tesla.Env.client, String.t, list(String.t), keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def remove_channel(connection, bridge_id, channel, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/removeChannel")
    |> add_param(:query, :"channel", channel)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - channel_id (String.t): Channel&#39;s id
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec set_video_source(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def set_video_source(connection, bridge_id, channel_id, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/videoSource/#{channel_id}")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Play music on hold to a bridge or change the MOH class that is playing.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - opts (KeywordList): [optional] Optional parameters
    - :moh_class (String.t): Channel&#39;s id

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec start_moh(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def start_moh(connection, bridge_id, opts \\ []) do
    optional_params = %{
      :"mohClass" => :query
    }
    %{}
    |> method(:post)
    |> url("/bridges/#{bridge_id}/moh")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end

  @doc """
  Stop playing music on hold to a bridge.
  This will only stop music on hold being played via POST bridges/{bridgeId}/moh.

  ## Parameters

  - connection (Asterisk.ARI.Connection): Connection to server
  - bridge_id (String.t): Bridge&#39;s id
  - opts (KeywordList): [optional] Optional parameters

  ## Returns

  {:ok, %{}} on success
  {:error, info} on failure
  """
  @spec stop_moh(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def stop_moh(connection, bridge_id, _opts \\ []) do
    %{}
    |> method(:delete)
    |> url("/bridges/#{bridge_id}/moh")
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> decode(false)
  end
end
